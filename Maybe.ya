package Maybe
  with Monad (Monad, MonadLaws)
  with Monad as Monad
  with Function (id)
  with Equal as Equal
where

def Maybe (A: Type) : Type =
   @self ∀
   (0 P   : ∀ (Maybe A) -> Type)
   (& none : P (data λ P n j => n))
   (& just : ∀ (x: A) -> P (data λ P n j => j x))
   -> P self

def none (0 A: Type) : Maybe A = data λ P n j => n
def just (0 A: Type) (x: A) : Maybe A = data λ P n j => j x

def bind (0 A : Type) (0 B: Type) (m: Maybe A) (fun: forall A -> (Maybe B)): Maybe B
  = (case m)
        (\m => Maybe B)
        (none B)
        fun

def default (A : Type) (m : Maybe A) (a : A): A
  = (case m) (\_ => A) a (id A)

def monad : Monad (Maybe)
  = Monad.new Maybe bind just

-- def monadLaws : MonadLaws Maybe monad =
--   Monad.proveMonadLaws Maybe monad
--     -- Equal (M B) (bind M impl A B (pure M impl A a) fun) (fun a)
--     (\A B a fun => Equal.)
