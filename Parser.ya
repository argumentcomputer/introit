//// Simple parser combinator library
//package Parser where
//
//open Monad (Monad)
//open Monad as Monad
//open MonadPlus (MonadPlus)
//open MonadPlus as MonadPlus
//open Functor as Functor
//open Functor (Functor)
//open List (List)
//open List as List
//open Pair (Pair)
//open Pair as Pair
//open Either (Either)
//open Either as Either
//open Alternative as Alternative
//open Alternative (Alternative)
//open Applicative as Applicative
//open Applicative (Applicative)
//open Bool as Bool
//open Bool (Bool, if)
//open String as String
//
//// A parser combinator type
//This can either succeed and produce a value of type A or fail with an empty list
//def Parser (A: Type) : Type =
//  @self ∀
//  (0 P: ∀ (Parser A) -> Type)
//  (& parser: ∀ (parse : ∀ #String -> List (Pair A #String)) -> P (data \P p => p parse))
//  -> P self
//
//def parser (0 A : Type) (parse : ∀ #String -> List (Pair A #String)) : Parser A
//  = data \P p => p parse
//
//// Monadic bind
//def bind (A B : Type) (p: Parser A) (fun : ∀ A -> Parser B): Parser B =
//  let fstA: ∀ (Pair A #String) -> A = Pair.fst A #String;
//  let snd: ∀ (Pair A #String) -> #String = Pair.snd A #String;
//  parser B (\str =>
//        (case p) (\_ => List (Pair B #String))
//            (\parseA => List.flatMap (Pair A #String) (Pair B #String)
//                (\pair => (case (fun (fstA pair))) (\_ => List (Pair B #String))
//                    (\parseB => parseB (snd pair))
//                )
//                (parseA str)
//            )
//  )
//
//// Identity parser also called unity
//def pure (0 A : Type) (a : A): Parser A
//  = parser A (\s => List.singleton (Pair A #String) (Pair.new A #String a s))
//
//def monad: Monad Parser
//  = Monad.new Parser bind pure
//
//// Runs a high level parser on the entire stream
//def runParser (A : Type) (p : Parser A) (str : #String) : Either A #String =
//  let fstA: ∀ (Pair A #String) -> A = Pair.fst A #String;
//  let snd: ∀ (Pair A #String) -> #String = Pair.snd A #String;
//  let error: ∀ #String -> Either A #String = Either.right A #String;
//  (case p) (\_ => Either A #String)
//        (\parse => (case (parse str)) (\_ => Either A #String)
//            (error "Parser error.")
//            (\head tail => (case tail) (\_ => Either A #String)
//                ((case (snd head)) (\_ => Either A #String)
//                    (Either.left A #String (fstA head))
//                    (\_ _ => error "Parser didn't consume entire string.")
//                )
//                (\_ _ => error "Multiple elements in top level.")
//            )
//        )
//
//// Advance the parser one char
//def item: Parser #Char
//  = parser #Char (\s => (case s) (\_ => List (Pair #Char #String))
//        (List.nil (Pair #Char #String))
//        (\c tail => List.singleton (Pair #Char #String) (Pair.new #Char #String c tail))
//    )
//
//// Map the parser value
//def map (A B : Type) (fun : ∀ A -> B) (p: Parser A): Parser B =
//  let fstA: ∀ (Pair A #String) -> A = Pair.fst A #String;
//  let snd: ∀ (Pair A #String) -> #String = Pair.snd A #String;
//  (case p) (\_ => Parser B)
//    (\parse => parser B
//      (\s =>
//        (List.map (Pair A #String) (Pair B #String)
//          (\pair => Pair.new B #String (fun (fstA pair)) (snd pair))
//          (parse s)
//        )
//      )
//    )
//
//def functor: Functor Parser
//  = Functor.new Parser map
//
//// Applicative combinator
//def applicate (A B : Type) (p1 : Parser (∀ A -> B)) (p2 : Parser A): Parser B =
//  let fstA  : ∀ (Pair A #String) -> A = Pair.fst A #String;
//  let fstAB : ∀ (Pair (∀ A -> B) #String) -> (∀ A -> B) = Pair.fst (∀ A -> B) #String;
//  let sndA  : ∀ (Pair A #String) -> #String = Pair.snd A #String;
//  let sndAB : ∀ (Pair (∀ A -> B) #String) -> #String = Pair.snd (∀ A -> B) #String;
//  parser B
//    (\str => (case p1) (\_ => (List (Pair B #String)))
//      (\parseAB => (case p2) (\_ => (List (Pair B #String)))
//        (\parseA =>
//          List.flatMap (Pair (∀ A -> B) #String) (Pair B #String)
//            (\pairAB =>
//              let s1 : #String = sndAB pairAB;
//              let f  : (∀ A -> B) = fstAB pairAB;
//              List.map (Pair A #String) (Pair B #String)
//                (\pairA =>
//                  let s2 : #String = sndA pairA;
//                  let a  : A = fstA pairA;
//                  Pair.new B #String (f a) s2
//                )
//                (parseA s1)
//            )
//            (parseAB str)
//        )
//      )
//    )
//
//// Concatenate the parsing result
//def combine (0 A : Type) (p1 : Parser A) (p2 : Parser A): Parser A =
//  parser A
//    (\str => (case p1) (\_ => List (Pair A #String))
//      (\parse1 => (case p2) (\_ => List (Pair A #String))
//        (\parse2 =>
//          List.concat (Pair A #String) (parse1 str) (parse2 str)
//        )
//      )
//    )
//
//def failure (0 A : Type): Parser A
//  = parser A (\s => List.nil (Pair A #String))
//
//// Choose between two options
//def option (0 A : Type) (p q : Parser A): Parser A =
//  (case p) (\_ => Parser A)
//      (\parseP =>
//        (case q) (\_ => Parser A)
//          (\parseQ =>
//            parser A (\str =>
//              (case (parseP str)) (\_ => List (Pair A #String))
//                (parseQ str)
//                (List.cons (Pair A #String))
//              )
//          )
//      )
//
//def applicative : Applicative Parser
//  = Applicative.new Parser functor pure applicate
//
//def alternative : Alternative Parser
//  = Alternative.new Parser applicative failure option
//
//def monadPlus : MonadPlus Parser
//  = MonadPlus.new Parser monad failure combine
//
//// Satisfy a Char predicate
//def satisfy (f : ∀ #Char -> Bool): Parser #Char =
//  bind #Char #Char 
//    item 
//    \c => if (Parser #Char) (f c) (pure #Char c) (failure #Char)
//
//def oneOf (str : #String): Parser #Char = 
//  satisfy (\c => String.in c str)
//
//// One or more Parser A separated by Parser (∀ A -> A -> A)
//def chain1 (A : Type) (p : Parser A) (op : Parser (∀ A A -> A)): Parser A =
//  letrec rest : ∀ A -> Parser A = (\a =>
//    option A
//      (Monad.bind Parser monad (∀ A A -> A) A
//        op
//        (\f => 
//        Monad.bind Parser monad A A
//          p
//          (\b =>
//            rest (f a b)
//          )
//        )
//      )
//      (pure A a)
//  );
//  Monad.bind Parser monad A A p (\a => rest a)
//
//def chain (A : Type) (p : Parser A) (op : Parser (∀ A A -> A)) (a : A): Parser A =
//  option A (chain1 A p op) (pure A a)
//
//def char (c : #Char): Parser #Char =
//  satisfy (\b => String.charEq c b)
//
//def string (s : #String): Parser #String =
//  (case s) (\_ => Parser #String)
//    (pure #String "")
//    (\c cs => 
//      Monad.bind Parser monad #Char #String
//        (char c)
//        (\_ => Monad.bind Parser monad #String #String
//          (string cs)
//          (\_ => Monad.pure Parser monad #String (#String.cons c cs))
//        )
//    )
//
//def whiteSpaces: Parser (List #Char) =
//  Alternative.many Parser alternative #Char (oneOf " \n\r")
//
//def token (A : Type) (p : Parser A): Parser A =
//  Monad.bind Parser monad A A
//    p
//    (\a =>
//      Monad.bind Parser monad (List #Char) A
//        whiteSpaces
//        (\_ => Monad.pure Parser monad A a)
//    )
//
//def reserved (s : #String): Parser #String =
//  token #String (string s)
//
//def digit: Parser #Char =
//  satisfy String.isDigit
//
//def inParentheses (A : Type) (p : Parser A): Parser A =
//  Monad.bind Parser monad #String A
//    (reserved "(")
//    (\_ => Monad.bind Parser monad A A
//      p
//      (\a => Monad.bind Parser monad #String A
//        (reserved ")")
//        (\_ => Monad.pure Parser monad A a)
//      )
//    )
