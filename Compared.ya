package Compared where

open Bool

def Compared : Type =
  @self ∀
  (0 P : ∀ Compared -> Type)
  (& ltn : P (data λ P l e g => l))
  (& eql : P (data λ P l e g => e))
  (& gtn : P (data λ P l e g => g))
  -> P self

def ltn : Compared = data λ P l e g => l
def eql : Compared = data λ P l e g => e
def gtn : Compared = data λ P l e g => g

def equals (a b : Compared): Bool
  = (case a) (λ _ => Bool)
        ((case b) (λ _ => Bool) true false false)
        ((case b) (λ _ => Bool) false true false)
        ((case b) (λ _ => Bool) false false true)

def Ordered (A : Type) : Type =
  @self ∀
  (0 P : ∀ (Ordered A) -> Type)
  (& new : ∀ (compare : ∀ (a b : A) -> Compared) -> P (data λ P n => n compare))
  -> P self

def newOrdered (0 A : Type) (compare : ∀ (a b : A) -> Compared): Ordered A
  = data λ P n => n compare

def compareOrdered (0 A : Type) (impl : Ordered A) (a b : A): Compared
  = (case impl) (λ _ => Compared)
        (λ compare => compare a b)

def isLessThan (0 A : Type) (impl : Ordered A) (a b : A): Bool
  = equals (compareOrdered A impl a b) ltn

def isLessThanOrEqual (0 A : Type) (impl : Ordered A) (a b : A): Bool
  = let cmp : Compared = compareOrdered A impl a b;
  (or (equals cmp ltn) (equals cmp eql))

def isEqual (0 A : Type) (impl : Ordered A) (a b : A): Bool
  = equals (compareOrdered A impl a b) eql

def isGreaterThanOrEqual (0 A : Type) (impl : Ordered A) (a b : A): Bool
  = let cmp : Compared = compareOrdered A impl a b;
  (or (equals cmp gtn) (equals cmp eql))

def isGreaterThan (0 A : Type) (impl : Ordered A) (a b : A): Bool
  = equals (compareOrdered A impl a b) gtn
