package Map where

open Pair as Pair
open Pair (Pair)
open Compared
open List (List)
open List as List
open Maybe (Maybe, none, just)

def Map (K: Type) (V: Type) (O: Ordered K): Type =
    @self forall
    (0 P : forall (Map K V O) -> Type)
    (& empty : P (data λ P e t => e))
    (& tie : forall (key : K) (value : V) (left : Map K V O) (right : Map K V O) -> P (data λ P e t => t key value left right))
    -> P self

def empty (0 K V: Type) (ordering : Ordered K): Map K V ordering
  = data λ P e t => e


def tie (0 K V: Type) (O : Ordered K) (key : K) (value : V) (left : Map K V O) (right : Map K V O): Map K V O
  = data λ P e t => t key value left right

def singleton (0 K V: Type) (ordering : Ordered K) (key : K) (value : V): Map K V ordering
  = tie K V ordering key value (empty K V ordering) (empty K V ordering)


def fromList (K V: Type) (ordering : Ordered K) (list : List (Pair K V)): Map K V ordering
  =
  let getKey : forall (Pair K V) -> K = Pair.fst K V;
  let getValue : forall (Pair K V) -> V = Pair.snd K V;
  let empty : Map K V ordering = empty K V ordering;
  let singleton : forall K V -> Map K V ordering = singleton K V ordering;
  let tie : forall K V (Map K V ordering) (Map K V ordering) -> (Map K V ordering) = tie K V ordering;
  (case list) (λ _ => Map K V ordering)
        empty
        (λ head tail =>
            let key : K = getKey head;
            let value : V = getValue head;
            (case tail) (λ _ => Map K V ordering)
                (singleton key value)
                (λ next skipTail =>
                    let nKey : K = getKey next;
                    let nValue : V = getValue next;
                    (case (compareOrdered K ordering key nKey))
                        (λ _ => Map K V ordering)
                        (tie key value (fromList K V ordering tail) empty)
                        (tie key value (fromList K V ordering skipTail) empty)
                        (tie key value empty (fromList K V ordering tail))
                )
        )

def toList (0 K V: Type) (ordering : Ordered K) (map : Map K V ordering): List (Pair K V)
  = (case map) (λ _ => List (Pair K V))
        (List.nil (Pair K V))
        (λ key value left right =>
            List.cons (Pair K V) (Pair.new K V key value)
                (List.concat (Pair K V) (toList K V ordering left) (toList K V ordering right))
        )

def mapMap (K V BK BV : Type) (ord : Ordered K) (ordB : Ordered BK) (f : ∀ (Pair K V) -> (Pair BK BV)) (map : Map K V ord): Map BK BV ordB
  =
  let l : List (Pair K V) = toList K V ord map;
  fromList BK BV ordB (List.map (Pair K V) (Pair BK BV) f l)


def put (0 K V: Type) (ord : Ordered K) (m : Map K V ord) (key : K) (value : V): Map K V ord =
  let singleton : forall K V -> Map K V ord = singleton K V ord;
  let tie : forall K V (Map K V ord) (Map K V ord) -> (Map K V ord) = tie K V ord;
  (case m) (λ _ => Map K V ord)
    (singleton key value)
    (λ tKey tValue left right => (case (compareOrdered K ord key tKey)) (λ _ => Map K V ord)
        (tie key tValue (put K V ord left key value) right)
        (tie key value left right)
        (tie key tValue left (put K V ord right key value))
    )


def lookup (0 K V: Type) (ord : Ordered K) (m : Map K V ord) (key : K): Maybe V
  = (case m) (λ _ => Maybe V)
        (none V)
        (λ fKey value left right =>
            (case (compareOrdered K ord key fKey)) (λ _ => Maybe V)
                (lookup K V ord left key)
                (just V value)
                (lookup K V ord right key)
        )

