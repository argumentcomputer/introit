package nat where

type Nat {
  Z,
  S Nat,
}

//def pred (x: Nat): Nat = (case x) (λ _ => Nat) Nat.Z (λ p => p)
//
//def add (a b: Nat): Nat
//  = (case a) (λ _ => Nat) b (λ pred => Nat.S (add pred b))
//
//def mul (a b: Nat): Nat
//  = (case a) (λ _ => Nat) Nat.Z (λ pred => add b (mul pred b))
//
//def from_prim (n : #Nat): Nat
//  = (case n) (λ _ => Nat)
//      Nat.Z
//      (λ pred => Nat.S (from_prim pred))
//
//def to_prim (n : Nat): #Nat
//  = (case n) (λ x => #Nat)
//      0
//      (λ pred => #Nat.suc (to_prim pred))
//
//def sub (n m: Nat): Nat
//  = (case m) (λ _ => Nat) n (λ x => (case n) (λ _ => Nat) Nat.Z (λ y => sub x y))
//
////def divMod_go (n m d: Nat): Pair Nat Nat =
////  (case (sub n m)) (λ _ => Pair Nat Nat)
////  (Pair.new Nat Nat d n)
////  (λ p => (divMod_go (succ p) m (succ d)))
////
////def divMod (n m: Nat): Pair Nat Nat = divMod_go n m zero
////
////def div (n m : Nat): Nat = Pair.fst Nat Nat (divMod n m)
////def mod (n m : Nat): Nat = Pair.snd Nat Nat (divMod n m)
////
////def compare (a b: Nat): Ordering
////  = (case a) (λ _ => Ordering)
////      ((case b) (λ _ => Ordering) Ord.eq (λ _ => Ord.lt))
////      (λ ap => (case b) (λ _ => Ordering) Ord.gt (λ bp => compare ap bp))
