package List.Sort
    with List (List, cons, singleton)
    with Compared (Compared)
where


def merge (0 A : Type) (ord : Ordered A) (as : List A) (bs : List A): List A =
  let cmp : ∀ A A -> Compared = compareOrdered A ord;
  (case as) (\_ => List A)
      (bs)
      (\a ass => (case bs) (\_ => List A)
             as
             (\b bss => (case (cmp a b)) (\_ => List A)
               (cons A a (merge A ord ass bs))
               (cons A a (merge A ord ass bs))
               (cons A b (merge A ord as bss))
             )
      )

def mergePairs (0 A : Type) (ord : Ordered A) (xs : List (List A)) : List (List A) =
     (case xs) (\_ => List (List A))
     (xs)
     (\a as =>
      (case as) (\_ => List (List A))
          (xs)
          (\b _ => cons (List A) (merge A ord a b) (mergePairs A ord as))
     )

def mergeAll (0 A : Type) (ord : Ordered A) (xs : List (List A)): List A =
     let mAllRec : List A = mergeAll A ord (mergePairs A ord xs);
     (case xs) (\_ => List A)
        (mAllRec)
        (\x xs =>
            (case xs) (\_ => List A)
                x
                (\_ _ => mAllRec)
        )

{| Split the list into ascending or descending sequences
|}
def sequences (0 A : Type) (ord : Ordered A) (l: List A): (List (List A)) =
  letrec cmp : ∀ A A -> Compared = compareOrdered A ord;
  letrec descending : ∀ (A) (List A) (List A) -> List (List A) =
  (\a as bs =>
    let seq : List (List A) = cons (List A) (cons A a as) (sequences A ord bs);
    (case bs) (\_ => List (List A))
        (seq)
        (\b bs => (case (cmp a b)) (\_ => List (List A))
           (seq)
           (seq)
           (descending b (cons A a as) bs))
  );
  letrec ascending : ∀ (A) (∀ (List A) -> List A) (List A) -> List (List A) =
  (\a as bs =>
     let cmp : ∀ A A -> Compared = compareOrdered A ord;
     let seq : List (List A) = cons (List A) (as (singleton A a)) (sequences A ord bs);
     (case bs) (\_ => List (List A))
       (seq)
       (\b bs => (case (cmp a b)) (\_ => List (List A))
         (ascending b (\ys => (as (cons A a ys))) bs)
         (ascending b (\ys => (as (cons A a ys))) bs)
         (seq)
       )
  );
  (case l) (\_ => List (List A))
    (singleton (List A) l)
    (\a lTail =>
        (case lTail) (\_ => List (List A))
            (singleton (List A) l)
            (\b xs =>
                (case (cmp a b)) (\_ => List (List A))
                    (ascending b (cons A a) xs) -- ltn
                    (ascending b (cons A a) xs) -- eql
                    (descending b (singleton A a) xs) -- gtn
            )
    )

{| Sort a list with merge sort
|}
def mergeSort (0 A : Type) (ord : Ordered A) (list : List A): List A =
  mergeAll A ord (sequences A ord list)
