package Alternative
  with Applicative (Applicative)
  with Applicative as Applicative
  with Functor as Functor
  with Functor (Functor)
  with List as List
  with List (List)
where

{| A structure for choosing between two alternatives
|}
def Alternative (F: ∀ Type -> Type) : Type =
  @self ∀
  (0 P: ∀ (Alternative F) -> Type)
  (& new: ∀
    (applicative : Applicative F)
    (empty: ∀ (A : Type) -> F A)
    (option: ∀ (A : Type) (p q : F A) -> F A)
    -> P (data \P n => n applicative empty option)
  ) -> P self

def new (0 F: ∀ Type -> Type)
        (applicative : Applicative F)
        (empty : ∀ (A : Type) -> F A)
        (option : ∀ (A : Type) (p q : F A) -> F A)
        : Alternative F
  = data \P n => n applicative empty option

def applicative (0 F: ∀ Type -> Type) (impl : Alternative F): Applicative F
  = (case impl) (\_ => Applicative F)
      (\applicativeF _ _ => applicativeF)

def functor (0 F: ∀ Type -> Type) (impl : Alternative F): Functor F
  = Applicative.functor F (applicative F impl)

{| Empty alternative
|}
def empty (0 F: ∀ Type -> Type) (impl : Alternative F) (A : Type): F A
  = (case impl) (\_ => F A)
      (\_ emptyF _ => emptyF A)

def option (0 F : ∀ Type -> Type) (impl : Alternative F)
           (A : Type) (p q : F A): F A  =
  (case impl) (\_ => F A)
      (\_ _ optionF => optionF A p q)

{| One or more
|}
def some (0 F: ∀ Type -> Type) (impl : Alternative F) (A : Type) (f : F A): F (List A) =
  let many_f : F (List A) = option F impl A (some F impl A f) (List.nil A);
  Functor.map Alternative (functor F impl) (List A) (List A)
    List.cons
    (Applicative.applicate F (applicative F impl) A (List A) f many_f)

{| Zero or more
|}
def many (0 F: ∀ Type -> Type) (impl : Alternative F) (A : Type) (f : F A): F (List A) =
  let many_f : F (List A) = option F impl A (some F impl A f) (List.nil A);
  Functor.map Alternative (functor F impl) (List A) (List A)
    List.cons
    (Applicative.applicate F (applicative F impl) A (List A) f many_f)
