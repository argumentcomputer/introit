//package Alternative where
//
//open Applicative (Applicative)
//open Applicative as Applicative
//open Functor as Functor
//open Functor (Functor)
//open List as List
//open List (List)
//
//// A structure for choosing between two alternatives
//def Alternative (F: ∀ Type -> Type) : Type =
//  @self ∀
//  (0 P: ∀ (Alternative F) -> Type)
//  (& new: ∀
//    (applicative : Applicative F)
//    (empty: ∀ (A : Type) -> F A)
//    (option: ∀ (A : Type) (p q : F A) -> F A)
//    -> P (data \P n => n applicative empty option)
//  ) -> P self
//
//def new (0 F: ∀ Type -> Type)
//        (applicative : Applicative F)
//        (empty : ∀ (A : Type) -> F A)
//        (option : ∀ (A : Type) (p q : F A) -> F A)
//        : Alternative F
//  = data \P n => n applicative empty option
//
//def applicative (0 F: ∀ Type -> Type) (impl : Alternative F): Applicative F
//  = (case impl) (\_ => Applicative F)
//      (\applicativeF _ _ => applicativeF)
//
//def pure (F : ∀ Type -> Type) (impl : Alternative F) (A : Type) (a : A): F A =
//  Applicative.pure F (applicative F impl) A a
//
//def functor (0 F: ∀ Type -> Type) (impl : Alternative F): Functor F
//  = Applicative.functor F (applicative F impl)
//
//// Empty alternative
//def empty (0 F: ∀ Type -> Type) (impl : Alternative F) (A : Type): F A
//  = (case impl) (\_ => F A)
//      (\_ emptyF _ => emptyF A)
//
//def option (0 F : ∀ Type -> Type) (impl : Alternative F)
//           (A : Type) (p q : F A): F A  =
//  (case impl) (\_ => F A)
//      (\_ _ optionF => optionF A p q)
//
//// One or more
//def some (F: ∀ Type -> Type) (impl : Alternative F) (A : Type) (f : F A): F (List A) =
//  let many_f : F (List A) = option F impl (List A)
//    (some F impl A f)
//    (pure F impl (List A) (List.nil A));
//  (Applicative.applicate F (applicative F impl) (List A) (List A)
//      (Functor.map F (functor F impl) A (∀ (List A) -> List A)
//        (List.cons A)
//        f
//      )
//      many_f
//  )
//
//// Zero or more
//def many (F: ∀ Type -> Type) (impl : Alternative F) (A : Type) (f : F A): F (List A) =
//  let some_f : F (List A) = 
//  (Applicative.applicate F (applicative F impl) (List A) (List A)
//    (Functor.map F (functor F impl) A (∀ (List A) -> List A)
//      (List.cons A)
//      f
//    )
//    (many F impl A f)
//  );
//  option F impl (List A) some_f (pure F impl (List A) (List.nil A))
