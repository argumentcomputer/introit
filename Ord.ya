package Ord
  import Bool as Bool
  import Bool (Bool, true, false, or)
where

def Ordering : Type =
  @self ∀
  (0 P : ∀ Ordering -> Type)
  (& lt: P (data λ P l e g => l))
  (& eq: P (data λ P l e g => e))
  (& gt: P (data λ P l e g => g))
  -> P self

def lt: Ordering = data λ P l e g => l
def eq: Ordering = data λ P l e g => e
def gt: Ordering = data λ P l e g => g

def Ord (A : Type) : Type =
  @self ∀
  (0 P : ∀ (Ord A) -> Type)
  (& new : ∀ (cmp : ∀ (a b : A) -> Ordering) -> P (data λ P n => n cmp))
  -> P self

def new (0 A : Type) (cmp : ∀ (a b: A) -> Ordering): Ord A
  = data λ P n => n cmp

def compare (0 A : Type) (impl: Ord A) (a b : A): Ordering
  = (case impl) (λ _ => Ordering) (λ cmp => cmp a b)

def Ordering.eql (a b : Ordering): Bool
  = (case a) (λ _ => Bool)
        ((case b) (λ _ => Bool) true false false)
        ((case b) (λ _ => Bool) false true false)
        ((case b) (λ _ => Bool) false false true)

def lth (0 A : Type) (impl : Ord A) (a b : A): Bool
  = Ordering.eql (compare A impl a b) lt

def eql (0 A : Type) (impl : Ord A) (a b : A): Bool
  = Ordering.eql (compare A impl a b) eq

def gth (0 A : Type) (impl : Ord A) (a b : A): Bool
  = Ordering.eql (compare A impl a b) gt

def lte (0 A : Type) (impl : Ord A) (a b : A): Bool
  = or (eql A impl a b) (lth A impl a b)

def gte (0 A : Type) (impl : Ord A) (a b : A): Bool
  = or (eql A impl a b) (gth A impl a b)

