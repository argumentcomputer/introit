package Nat
  import Pair as Pair
  import Pair (Pair)
  import Ord as Ord
  import Ord (Ord, Ordering)
where

def Nat : Type =
  @self ∀
  (0 P : ∀ Nat -> Type)
  (& zero : (P (data λ P z s => z)))
  (& succ : ∀ (pred : Nat) -> (P (data λ P z s => s pred)))
  -> P self

def zero: Nat = data λ P z s => z
def succ (x: Nat): Nat = data λ P z s => s x

def pred (x: Nat): Nat = (case x) (λ _ => Nat) zero (λ p => p)

def add (a b: Nat): Nat
  = (case a) (λ _ => Nat) b (λ pred => succ (add pred b))

def mul (a b: Nat): Nat
  = (case a) (λ _ => Nat) zero (λ pred => add b (mul pred b))

def from_prim (n : #Nat): Nat
  = (case n) (λ _ => Nat)
      zero
      (λ pred => succ (from_prim pred))

def to_prim (n : Nat): #Nat
  = (case n) (λ x => #Nat)
      0
      (λ pred => #Nat.suc (to_prim pred))

def sub (n m: Nat): Nat
  = (case m) (λ _ => Nat) n (λ x => (case n) (λ _ => Nat) zero (λ y => sub x y))

def divMod_go (n m d: Nat): Pair Nat Nat =
  (case (sub n m)) (λ _ => Pair Nat Nat)
  (Pair.new Nat Nat d n)
  (λ p => (divMod_go (succ p) m (succ d)))

def divMod (n m: Nat): Pair Nat Nat = divMod_go n m zero

def div (n m : Nat): Nat = Pair.fst Nat Nat (divMod n m)
def mod (n m : Nat): Nat = Pair.snd Nat Nat (divMod n m)

def compare (a b: Nat): Ordering
  = (case a) (λ _ => Ordering)
      ((case b) (λ _ => Ordering) Ord.eq (λ _ => Ord.lt))
      (λ ap => (case b) (λ _ => Ordering) Ord.gt (λ bp => compare ap bp))
