package Vector
  with Nat (Nat, zero, succ, Addable, newAddable)
  with Nat as Nat
  with Unit (Unit)
  with Unit as Unit
  with Pair (Pair)
  with Pair as Pair
where

def Vector (A: Type) (k: Nat): Type =
  @self ∀
  (0 P : ∀ (k: Nat) (Vector A k) -> Type)
  (& nil : P zero (data λ P n c => n))
  (& cons: ∀ (0 k: Nat) (x: A) (xs: Vector A k) -> P (succ k) (data λ P n c => c k x xs))
  -> P k self

def nil (0 A: Type) : Vector A zero
  = data λ P n c => n

def cons (0 A: Type) (0 k: Nat) (x: A) (xs: Vector A k): Vector A (succ k)
  = data λ P n c => c k x xs

def fill (0 A: Type) (n: Nat) (a: A): Vector A n
  = (case n) (\ x => (Vector A x))
       (nil A)
       (\ pred => cons A pred a (fill A pred a))

def extract (0 A: Type) (0 size: Nat) (xs: Vector A (succ size)): Pair A (Vector A size)
  = (case xs)
      (\k _ => (case k) (\_ => Type) Unit (\pred => Pair A (Vector A pred)))
      Unit.new
      (\k y ys => Pair.new A (Vector A k) y ys)

def add (0 A : Type) (impl : Addable A) (0 size : Nat) (as bs: Vector A size): Vector A size
  = (case impl) (\_ => Vector A size)
        (\add_a =>
            (case as) (\k _ => forall (Vector A k) -> Vector A k)
                (\bs => bs)
                (\k a as bs => (case (extract A k bs))
                       (\_ => Vector A (Nat.succ k))
                       (\b bs => cons A k (add_a a b) (add A impl k as bs)))
                bs)

def deriveAddable (0 A: Type) (impl: Addable A) (0 size: Nat): Addable (Vector A size)
  = newAddable (Vector A size) (add A impl size)
