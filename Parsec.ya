// This package is an adaptation of the Haskell Megaparsec library found at
// https://hackage.haskell.org/package/megaparsec
package Parsec
  import Unit as Unit
  import Unit (Unit)
  import Bool as Bool
  import List as List
  import List (List)
  import Maybe as Maybe
  import Maybe (Maybe)
  import Char as Char
  import Char (Char)
  import Text as Text
  import Text (Text)
  import Nat as Nat
  import Nat (Nat)
  import Either as Either
  import Either (Either)
  import Parsec.Error (Error, Item, Fancy)
  import Parsec.Error as Error
  import Parsec.State (State)
  import Parsec.State as State
  import Parsec.Reply (Reply)
  import Parsec.Reply as Reply
where

// A parser is a continuation:
// For custom State type S, custom Error type E, and return type A,
// For all possible continuation types B (i.e. all possible parser compositions)
// We take a Parsec.State with custom state and errors
// and run one of four possible continuation functions on it
// - (eok) processes a state and a  value when no input was consumed
// - (eer) processes a state and an error when no input was consumed
// - (cok) processes a state and a  value when input was consumed
// - (cer) processes a state and an error when input was consumed
def Parsec (S E A: Type): Type =
  ∀ (B: Type)
    (state: State S E)
    (∀ (State S E) A -> B)
    (∀ (State S E) (Error E) -> B)
    (∀ (State S E) A -> B)
    (∀ (State S E) (Error E) -> B)
  -> B

def run (S E A: Type) (parser: Parsec S E A) (state: State S E): Reply S E A
  = parser (Reply S E A) state
    (Reply.eok S E A)
    (Reply.eer S E A)
    (Reply.cok S E A)
    (Reply.cer S E A)

def parse (S E A: Type) (parser: Parsec S E A) (state: State S E)
  : Either (Error E) A
  = Reply.toEither S E A (run S E A parser state)

def Parsed (S E A: Type) (reply: Reply S E A): Type =
  (case reply) (λ _ => Type)
  (λ _ _ => A)
  (λ _ _ => Error E)
  (λ _ _ => A)
  (λ _ _ => Error E)

def parsed (S E A: Type) (parser: Parsec S E A) (state: State S E)
  : Parsed S E A (run S E A parser state)
  = (case (run S E A parser state)) (λ reply => Parsed S E A reply)
    (λ _ x => x)
    (λ _ e => e)
    (λ _ x => x)
    (λ _ e => e)

def pure (S E A: Type) (a: A): Parsec S E A = λ _ s eok _ _ _ => eok s a

def map (S E A B: Type) (f: ∀ A -> B) (p: Parsec S E A): Parsec S E B =
  λ B s1 eok eer cok cer => p B s1
   (λ s2 a => eok s2 (f a))
   eer
   (λ s2 a => cok s2 (f a))
   cer

def bind (S E A B: Type) (p: Parsec S E A) (f: ∀ A -> Parsec S E B)
  : Parsec S E B
  = λ B s1 eok eer cok cer => p B s1
    (λ s2 a => f a B s2 (λ s3 b => eok s3 b) eer (λ s3 b => cok s3 b) cer)
    eer
    (λ s2 a => f a B s2 (λ s3 b => cok s3 b) cer (λ s3 b => cok s3 b) cer)
    cer

def ap (S E A B: Type) (pf: Parsec S E (∀ A -> B)) (pa: Parsec S E A)
  : Parsec S E B
  = λ B s1 eok eer cok cer => pf B s1
  (λ s2 f => pa B s2 (λ s3 a => eok s3 (f a)) eer (λ s3 a => cok s3 (f a)) cer)
  eer
  (λ s2 f => pa B s2 (λ s3 a => cok s3 (f a)) cer (λ s3 a => cok s3 (f a)) cer)
  cer

def state (S E: Type): Parsec S E (State S E) =
  λ B s1 eok eer cok cer => eok s1 s1

def token (S E A: Type) (f: ∀ Char -> Maybe A) (exps: List Item): Parsec S E A
  = λ B s1 eok eer cok cer =>
  (case s1) (λ _ => B) (λ pos txt err ste => 
    (case txt) (λ _ => B)
      (eer s1 (Error.trivial E pos (Maybe.some Item Error.eof) exps))
      (λ c cs => (case (f c)) (λ _ => B)
        (eer s1
          (Error.trivial E pos
            (Maybe.some Item (Error.tokens (Text.single c)))
            exps
          )
        )
        (λ x => cok (State.new S E (Nat.succ pos) cs err ste) x)
      )
  )

def char (S E: Type) (c: Char): Parsec S E Char =
  token S E Char
    (λ x => (case (Char.eql x c)) (λ _ => Maybe Char)
      (Maybe.some Char c)
      (Maybe.none Char)
    )
    (List.single Item (Error.tokens (Text.single c)))

def anyChar (S E: Type): Parsec S E Char =
  token S E Char (Maybe.some Char) (List.single Item (Error.label "any char"))

def zero (S E A: Type): Parsec S E A = λ B s1 eok eer cok cer =>
  (case s1) (λ _ => B) (λ pos _ _ _ =>
    eer s1 (Error.trivial E pos (Maybe.none Item) (List.nil Item))
  )

def plus (S E A: Type) (x y: Parsec S E A): Parsec S E A =
  λ B s1 eok eer cok cer => x B s1
    eok
    (λ s2 xe => y B s1
      eok
      (λ s3 ye => eer (State.longestMatch S E s2 s3) (Error.merge E xe ye))
      cok
      (λ s3 ye => cer (State.longestMatch S E s2 s3) (Error.merge E xe ye))
    )
    cok
    cer

def choice (S E A: Type) (ps: List (Parsec S E A)): Parsec S E A =
  (case ps) (λ _ => Parsec S E A)
    (zero S E A)
    (λ p ps => plus S E A p (choice S E A ps))

def eof (S E: Type): Parsec S E Unit = λ B s1 eok eer cok cer =>
  (case s1) (λ _ => B) (λ pos input err ste =>
    (case input) (λ _ => B)
      (eok s1 Unit.new)
      (λ c cs => eer s1 (Error.trivial E pos
        (Maybe.some Item (Error.tokens (Text.single c)))
        (List.single Item Error.eof)
        )
      )
  )

def fail (S E A: Type) (msg: Text): Parsec S E A = λ B s1 eok eer cok cer =>
  (case s1) (λ _ => B) (λ pos txt errs ste => 
    eer s1 (Error.fancy E pos (List.single (Fancy E) (Error.fail E msg)))
  )

def try (S E A: Type) (p: Parsec S E A): Parsec S E A =
  λ B s1 eok eer cok cer => p B s1
    eok (λ s2 e => eer s1 e) cok (λ s2 e => eer s1 e)

def label (S E A: Type) (msg: Text) (p: Parsec S E A): Parsec S E A =
  λ B s1 eok eer cok cer => p B s1
    eok
    (λ s2 e => (case e) (λ _ => B)
      (λ pos unx exp => eer s2 
        (Error.trivial E pos unx (List.single Item (Error.label msg)))
      )
      (λ _ _ => eer s2 e)
    )
    cok
    cer

def make (S E A: Type) (f: ∀ (State S E) -> Reply S E A): Parsec S E A =
  λ B s1 eok eer cok cer => (case (f s1)) (λ _ => B) eok eer cok cer

def optional (S E A: Type) (p: Parsec S E A): Parsec S E (Maybe A) =
  plus S E (Maybe A)
    (map S E A (Maybe A) (Maybe.some A) p)
    (pure S E (Maybe A) (Maybe.none A))

def many (S E A: Type) (p: Parsec S E A): Parsec S E (List A) =
  bind S E (Maybe A) (List A)
    (optional S E A p)
    (λ x => (case x) (λ _ => Parsec S E (List A))
      (pure S E (List A) (List.nil A))
      (λ a => map S E (List A) (List A) (List.cons A a) 
        (many S E A p))
    )

def take (S E: Type) (err: Text) (n: Nat): Parsec S E Text =
  λ B s1 eok eer cok cer => (case s1) (λ _ => B) (λ pos inp errs ste =>
    (case (Nat.gth n (Text.lenChars inp))) (λ _ => B)
      (eer s1 (Error.trivial E pos (Maybe.some Item Error.eof)
        (List.single Item (Error.label err)))
      )
      ((case (Text.split n inp)) (λ _ => B) (λ took rest =>
      cok (State.new S E (Nat.add n pos) rest errs ste) took
      ))
  )

def manyTill (S E A B: Type) (p: Parsec S E A) (end: Parsec S E B)
  : Parsec S E (List A)
  = plus S E (List A) 
  (bind S E B (List A) end (λ _ => pure S E (List A) (List.nil A)))
  (bind S E A (List A) p (λ x =>
  (bind S E (List A) (List A) (manyTill S E A B p end) (λ xs => 
  (pure S E (List A) (List.cons A x xs))))))

def observing (S E A: Type) (p: Parsec S E A): Parsec S E (Either (Error E) A)
  = λ B s1 eok eer cok cer => p B s1
  (λ s2 x => eok s2 (Either.right (Error E) A x))
  (λ s2 e => eok s2 (Either.left (Error E) A e))
  (λ s2 x => cok s2 (Either.right (Error E) A x))
  (λ s2 e => cok s2 (Either.left (Error E) A e))

def peek (S E A: Type) (p: Parsec S E A): Parsec S E A = 
  λ B s1 eok eer cok cer => p B s1
  (λ s2 a => eok s1 a)
  eer
  (λ s2 a => cok s1 a)
  cer

