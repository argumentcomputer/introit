package Nat where

def Nat : Type =
  @self ∀
  (0 P : ∀ Nat -> Type)
  (& zero : (P (data λ P z s => z)))
  (& succ : ∀ (pred : Nat) -> (P (data λ P z s => s pred)))
  -> P self

def zero: Nat = data λ P z s => z

def succ (x: Nat): Nat = data λ P z s => s x

def pred (x: Nat): Nat = (case x) (λ _ => Nat) zero (λ p => p)

def add (a b: Nat): Nat
  = (case a) (\x => Nat)
        b
        (\pred => succ (add pred b))

def mul (a b : Nat): Nat
  = (case a) (\x => Nat)
        zero
        (\pred => add b (mul pred b))

def from_natural (n : #Natural): Nat
  = (case n) (\x => Nat)
        zero
        (\pred => succ (from_natural pred))

def to_natural (n : Nat): #Natural
  = (case n) (\x => #Natural)
        0
        (\pred => #Natural_succ (to_natural pred))

def Addable (A: Type) : Type =
  @self forall
  (0 P: forall (Addable A) -> Type)
  (newAddable: forall
    (add: forall (a b: A) -> A)
    -> P (data \P n => n add)
  ) -> P self

def newAddable (0 A: Type) (add: forall (a b: A) -> A): Addable A
  = data \P n => n add

def natAddable: Addable Nat
  = newAddable Nat add

def naturalAddable: Addable #Natural
  = newAddable #Natural #Natural_add

def addAddables (0 A: Type) (impl: Addable A) (x y: A): A
  = (case impl) (\_ => A)
        (\add_a => add_a x y)
