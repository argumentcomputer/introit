package Nat
  with Either
  with Pair (Pair)
  with Pair as Pair
  with Bool (Bool, if, and, or)
  with Bool as Bool
  with Compared as Compared
  with Compared (Compared)
where

def Nat : Type =
  @self ∀
  (0 P : ∀ Nat -> Type)
  (& zero : (P (data λ P z s => z)))
  (& succ : ∀ (pred : Nat) -> (P (data λ P z s => s pred)))
  -> P self

def zero: Nat = data λ P z s => z

def succ (x: Nat): Nat = data λ P z s => s x

def pred (x: Nat): Nat = (case x) (λ _ => Nat) zero (λ p => p)

def add (a b: Nat): Nat
  = (case a) (\x => Nat)
        b
        (\pred => succ (add pred b))

def mul (a b : Nat): Nat
  = (case a) (\x => Nat)
        zero
        (\pred => add b (mul pred b))

def from_natural (n : #Natural): Nat
  = (case n) (\x => Nat)
        zero
        (\pred => succ (from_natural pred))

def to_natural (n : Nat): #Natural
  = (case n) (\x => #Natural)
        0
        (\pred => #Natural_succ (to_natural pred))

def Addable (A: Type) : Type =
  @self forall
  (P: forall (Addable A) -> Type)
  (newAddable: forall
    (add: forall (a b: A) -> A)
    -> P (data \P n => n add)
  ) -> P self

def newAddable (A: Type) (add: forall (a b: A) -> A): Addable A
  = data \P n => n add

def natAddable: Addable Nat
  = newAddable Nat add

def naturalAddable: Addable #Natural
  = newAddable #Natural #Natural_add

def addAddables (A: Type) (impl: Addable A) (x y: A): A
  = (case impl) (\_ => A)
        (\add_a => add_a x y)

-- Subtraction of Nat (n - m)
-- The sign is encoded in Either; right is minus left is plus.
def sub (n : Nat) (m : Nat): Either Nat Nat
  = (case m) (\_ => Either Nat Nat)
        (left Nat Nat n)
        (\m_pred =>
            (case n) (\_ => Either Nat Nat)
                (right Nat Nat (succ m_pred))
                (\n_pred => sub n_pred m_pred))

-- Division with remainder
def divMod (n : Nat) (m : Nat): Pair Nat Nat =
  letrec fun : (forall Nat Nat Nat -> Pair Nat Nat) =
    (\n m d => (case (sub n m)) (\_ => Pair Nat Nat)
        (\r => fun r m (succ d))
        (\r => Pair.new Nat Nat d n)
    );
  fun n m zero

-- Modulo division
def mod (n m : Nat): Nat = Pair.fst Nat Nat (divMod n m)

-- Compare two Nat returns a Compared
def compare (a b : Nat): Compared
  = (case a) (\_ => Compared)
        ((case b) (\_ => Compared) Compared.eql (\_ => Compared.ltn))
        (\a_pred => (case b) (\_ => Compared)
            Compared.gtn
            (\b_pred => compare a_pred b_pred)
        )

-- Greater than a > b
def gtn (a b : Nat): Bool
  = Compared.equals (compare a b) Compared.gtn

-- Less than a < b
def ltn (a b : Nat): Bool
  = Compared.equals (compare a b) Compared.ltn

-- Less than or equal a <= b
def lte (a b : Nat): Bool
  = let c : Compared = compare a b;
  or (Compared.equals c Compared.ltn) (Compared.equals c Compared.gtn)

-- Equals a = b
def eql (a b : Nat): Bool
  = Compared.equals (compare a b) Compared.eql
