package Nat
  with Either
  with Pair (Pair)
  with Pair as Pair
  with List as List
  with List (List)
where

def Nat : Type =
  @self ∀
  (0 P : ∀ Nat -> Type)
  (& zero : (P (data λ P z s => z)))
  (& succ : ∀ (pred : Nat) -> (P (data λ P z s => s pred)))
  -> P self

def zero: Nat = data λ P z s => z

def succ (x: Nat): Nat = data λ P z s => s x

def pred (x: Nat): Nat = (case x) (λ _ => Nat) zero (λ p => p)

def add (a b: Nat): Nat
  = (case a) (\x => Nat)
        b
        (\pred => succ (add pred b))

def mul (a b : Nat): Nat
  = (case a) (\x => Nat)
        zero
        (\pred => add b (mul pred b))

def from_natural (n : #Natural): Nat
  = (case n) (\x => Nat)
        zero
        (\pred => succ (from_natural pred))

def to_natural (n : Nat): #Natural
  = (case n) (\x => #Natural)
        0
        (\pred => #Natural_succ (to_natural pred))

def Addable (A: Type) : Type =
  @self forall
  (P: forall (Addable A) -> Type)
  (newAddable: forall
    (add: forall (a b: A) -> A)
    -> P (data \P n => n add)
  ) -> P self

def newAddable (A: Type) (add: forall (a b: A) -> A): Addable A
  = data \P n => n add

def natAddable: Addable Nat
  = newAddable Nat add

def naturalAddable: Addable #Natural
  = newAddable #Natural #Natural_add

def addAddables (A: Type) (impl: Addable A) (x y: A): A
  = (case impl) (\_ => A)
        (\add_a => add_a x y)

-- Subtraction of Nat (n - m)
-- The sign is encoded in Either; right is minus left is plus.
def sub (n : Nat) (m : Nat): Either Nat Nat
  = (case m) (\_ => Either Nat Nat)
        (left Nat Nat n)
        (\m_pred =>
            (case n) (\_ => Either Nat Nat)
                (right Nat Nat (succ m_pred))
                (\n_pred => sub n_pred m_pred))

-- Division with remainder
def divMod (n : Nat) (m : Nat): Pair Nat Nat =
  letrec fun : (forall Nat Nat Nat -> Pair Nat Nat) =
    (\n m d => (case (sub n m)) (\_ => Pair Nat Nat)
        (\r => fun r m (succ d))
        (\r => Pair.new Nat Nat d n)
    );
  fun n m zero

def toBase (base : Nat) (n : Nat): List Nat
  = letrec fun : (forall Nat Nat (List Nat) -> List Nat) =
        (\base n list => (case (divMod n base)) (\_ => List Nat)
            (\div mod =>
                let l : List Nat = List.cons Nat mod list;
                (case div) (\_ => List Nat)
                    l
                    (\_ => fun base div l)
            )
        );
    fun base n (List.nil Nat)

--def toStringOfBase (base : Nat) (n : Nat): #String
--  = map 
