package Reply
  import Either as Either
  import Either (Either)
  import Parsec.Error
  import Parsec.State
where

// A Reply over custom state S, custom error E and return value A can be:
// + eok when the parser returns an A value and input was not consumed
// + eer when the parser throws an E error and input was not consumed
// + cok when the parser returns an A value and input was consumed
// + cer when the parser throws an E error and input was consumed
def Reply (S E A: Type): Type =
  @self ∀
  (0 P: ∀ (Reply S E A) -> Type)
  (& eok: ∀ (state: State S E) (val: A)
    -> P (data λ P eok eer cok cer => eok state val)
  )
  (& eer: ∀ (state: State S E) (err: Error E)
    -> P (data λ P eok eer cok cer => eer state err)
  )
  (& cok: ∀ (state: State S E) (val: A)
    -> P (data λ P eok eer cok cer => cok state val)
  )
  (& cer: ∀ (state: State S E) (err: Error E)
    -> P (data λ P eok eer cok cer => cer state err)
  )
  -> P self

def eok (S E A: Type) (state: State S E) (val: A): Reply S E A
  = data λ P eok eer cok cer => eok state val

def eer (S E A: Type) (state: State S E) (err: Error E): Reply S E A
  = data λ P eok eer cok cer => eer state err

def cok (S E A: Type) (state: State S E) (val: A): Reply S E A
  = data λ P eok eer cok cer => cok state val

def cer (S E A: Type) (state: State S E) (err: Error E): Reply S E A
  = data λ P eok eer cok cer => cer state err

def toEither (S E A: Type) (reply: Reply S E A): Either (Error E) A
  = (case reply) (λ _ => Either (Error E) A)
    (λ s a => Either.right (Error E) A a)
    (λ s e => Either.left (Error E) A e)
    (λ s a => Either.right (Error E) A a)
    (λ s e => Either.left (Error E) A e)
