package Error
  import Bool as Bool
  import Either as Either
  import Either (Either)
  import List as List
  import List (List)
  import Maybe as Maybe
  import Maybe (Maybe)
  import Text as Text
  import Text (Text)
  import Nat as Nat
  import Nat (Nat)
where

// #Parsec Errors

// Items are possible things at a given offset in the input
// a parser might expect to see, or alternatively might *not* expect to see:
// + tokens or characters such as "a", "b", "&", "ϝ", "\ACK"
// + labels or tags that can be attached to parsers, such as "an ascii char"
// + the end of the input stream
def Item: Type =
  @self ∀
  (0 P: ∀ Item -> Type)
  (& tokens: ∀ (tokens: Text) -> P (data λ P t l e => t tokens))
  (& label:  ∀ (label : Text) -> P (data λ P t l e => l label))
  (& eof: P (data λ P t l e => e))
  -> P self

def tokens (tok: Text): Item = data λ P t l e => t tok
def label (lbl: Text): Item = data λ P t l e => l lbl
def eof: Item = data λ P t l e => e

// A Fancy error is where the parser author preempts the internal error system
// and instead returns a custom failure message or a value of custom type E
def Fancy (E: Type): Type =
  @self ∀
  (0 P: ∀ (Fancy E) -> Type)
  (& fail: ∀ (msg: Text) -> P (data λ P f c => f msg))
  (& custom: ∀ (err: E) -> P (data λ P f c => c err))
  -> P self

def fail (E: Type) (msg: Text): Fancy E = data λ P f c => f msg
def custom (E: Type) (err: E): Fancy E = data λ P f c => c err

// A parser error can be either
// + a trivial error containing
//   * the offset at which the error occured
//   * possibly an unexpected Item which triggered the error at that offset
//   * a list of expected Items at that offset
// + a user specified custom error containing
//  * the offset at which the error occured
//  * a list of Fancy error messages at that offset
def Error (E: Type): Type =
  @self ∀
  (0 P: ∀ (Error E) -> Type)
  (& trivial: ∀ (pos: Nat) (unexpected: Maybe Item) (expected: List Item)
    -> P (data λ P t f => t pos unexpected expected)
  )
  (& fancy: ∀ (pos: Nat) (messages: List (Fancy E))
    -> P (data λ P t f => f pos messages)
  )
  -> P self

def trivial (E: Type)
  (pos: Nat)
  (unexpected: Maybe Item)
  (expected: List Item)
  : Error E
  = data λ P t f => t pos unexpected expected

def fancy (E: Type) (pos: Nat) (messages: List (Fancy E)): Error E =
  data λ P t f => f pos messages

def index (E: Type) (x: Error E): Nat =
  (case x) (λ _ => Nat) (λ pos _ _ => pos) (λ pos _ => pos)

// When a parser branches and tries different possible options on its input
// we need some way to combine the errors that each branch generates.
// Because branches that consume more input are better than those that do less
// the errors from farther along the input are more useful.
// Thus to merge errors we compare positions and throw away the earlier error.
// If both errors occur at the same place though, we prefer fancy errors.
// If both errors are fancy at the same place, we merge the messages.
// If both errors are trivial at the same place, we merge the expected items.
// (We also try to prefer the presence of an unexpected token over its absence)
def merge (E: Type) (x y: Error E): Error E = 
  (case x) (λ _ => Error E)
  (λ x_pos x_unx x_exp => (case y) (λ _ => Error E) 
    (λ y_pos y_unx y_exp =>
      (case (Nat.cmp x_pos y_pos)) (λ _ => Error E)
        y
        (trivial E x_pos x_unx (List.concat Item x_exp y_exp))
        x
    )
    (λ y_pos y_msg => (case (Nat.cmp x_pos y_pos)) (λ _ => Error E) y y x)
  )
  (λ x_pos x_msg => (case y) (λ _ => Error E) 
    (λ y_pos y_unx y_exp => (case (Nat.cmp x_pos y_pos)) (λ _ => Error E) y x x)
    (λ y_pos y_msg => (case (Nat.cmp x_pos y_pos)) (λ _ => Error E)
      y
      (fancy E x_pos (List.concat (Fancy E) x_msg y_msg))
      x
    )
  )





