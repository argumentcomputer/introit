package Show
  with Function
  with Nat
  with List (List)
  with List as List
  with Map (Map)
  with Map as Map
  with Bool
  with Maybe (Maybe)
  with Maybe as Maybe
where

def Show (A: Type) : Type =
  @self forall
  (0 P: forall (Show A) -> Type)
  (& newShow: forall
    (show: forall (a: A) -> #String)
    -> P (data \P n => n show)
  ) -> P self

def newShow (0 A: Type) (show: forall (a: A) -> #String): Show A
  = data \P n => n show

def show (0 A: Type) (impl: Show A) (x: A): #String
  = (case impl) (\_ => #String)
        (\show_a => show_a x)

def stringShow: Show #String
  = newShow #String (id #String)

def base64 : List #Char =
    (List.cons #Char '0' (List.cons #Char '1' (List.cons #Char '2' (List.cons #Char '3' (List.cons #Char '4' (List.cons #Char '5'
    (List.cons #Char '6' (List.cons #Char '7' (List.cons #Char '8' (List.cons #Char '9' (List.cons #Char 'A' (List.cons #Char 'B'
    (List.cons #Char 'C' (List.cons #Char 'D' (List.cons #Char 'E' (List.cons #Char 'F' (List.cons #Char 'G' (List.cons #Char 'H'
    (List.cons #Char 'I' (List.cons #Char 'J' (List.cons #Char 'K' (List.cons #Char 'L' (List.cons #Char 'M' (List.cons #Char 'N'
    (List.cons #Char 'O' (List.cons #Char 'P' (List.cons #Char 'Q' (List.cons #Char 'R' (List.cons #Char 'S' (List.cons #Char 'T'
    (List.cons #Char 'U' (List.cons #Char 'V' (List.cons #Char 'W' (List.cons #Char 'X' (List.cons #Char 'Y' (List.cons #Char 'Z'
    (List.cons #Char 'a' (List.cons #Char 'b' (List.cons #Char 'c' (List.cons #Char 'd' (List.cons #Char 'e' (List.cons #Char 'f'
    (List.cons #Char 'g' (List.cons #Char 'h' (List.cons #Char 'i' (List.cons #Char 'j' (List.cons #Char 'k' (List.cons #Char 'l'
    (List.cons #Char 'm' (List.cons #Char 'n' (List.cons #Char 'o' (List.cons #Char 'p' (List.cons #Char 'q' (List.cons #Char 'r'
    (List.cons #Char 's' (List.cons #Char 't' (List.cons #Char 'u' (List.cons #Char 'v' (List.cons #Char 'w' (List.cons #Char 'x'
    (List.cons #Char 'y' (List.cons #Char 'z' (List.cons #Char '+' (List.cons #Char '/' (List.nil #Char))))
    )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))


def showDigit (base n : Nat): #String
  =
  let m : Nat = mod n base;
  #String_cons
    (if #Char
        (and (gtn base (from_natural 0)) (lte base (from_natural 64)))
        (Maybe.default #Char (List.at #Char base64 m) '#')
        '#'
    )
    ""

def toBase (base : Nat) (n : Nat): List Nat
  = letrec fun : (forall Nat Nat (List Nat) -> List Nat) =
        (\base n list => (case (divMod n base)) (\_ => List Nat)
            (\div mod =>
                let l : List Nat = List.cons Nat mod list;
                (case div) (\_ => List Nat)
                    l
                    (\_ => fun base div l)
            )
        );
    fun base n (List.nil Nat)

def toStringOfBase (base : Nat) (n : Nat): #String
  = let digits : List Nat = toBase base n;
  List.foldr Nat #String (\digit str => #String_concat str (showDigit (from_natural 10) digit)) "" digits

def natShow: Show Nat
  = newShow Nat (toStringOfBase (from_natural 10))


def deriveMaybeShow (A : Type) (impl : Show A): Show (Maybe A)
  = newShow (Maybe A)
        (\m =>
            (case m) (\_ => #String)
                "none"
                (\a => #String_concat "just " (show A impl a))
        )

def deriveListShow (A : Type) (impl : Show A): Show (List A)
  = let subShow : forall A #String -> #String = (\a str =>
        #String_concat str (#String_concat ", " (show A impl a))
    );
  newShow (List A)
        (\list =>
            #String_concat "List [" (#String_concat (List.foldr A #String subShow "" list) "]")
        )

def derivePairShow (A B : Type) (implA : Show A) (implB : Show B): Show (Pair A B)
  = newShow (Pair A B)
        (\p =>
            (case p) (\_ => #String)
                (\a b => #String_concat "("
                    (#String_concat (show A implA a)
                    (#String_concat ", " (#String_concat (show B implB b) ")")))
                )
        )

def deriveMapShow (K V : Type) (ord : Ordered K) (implK : Show K) (implV : Show V): Show (Map K V ord)
  =
  letrec pairShow : ∀ (Pair K V) -> #String = (\p =>
    #String_concat (show K implK (Pair.fst K V p))
    (#String_concat " => " (show V implV (Pair.snd K V p)))
  );
  letrec subShow : ∀ (Pair K V) #String -> #String = (\p str =>
        #String_concat str (#String_concat ", " (pairShow p))
    );
  newShow (Map K V ord)
        (\m =>
            let list : List (Pair K V) = Map.toList K V ord m;
            #String_concat "Map {"
            (#String_concat (List.foldr (Pair K V) #String subShow "" list) "}")
        )
