package Show
  with Function
  with Nat
  with List (List)
  with List as List
  with Vector as Vector
  with Vector (Vector)
  with Matrix as Matrix
  with Matrix (Matrix)
  with Map (Map)
  with Map as Map
  with Bool
  with Maybe (Maybe)
  with Maybe as Maybe
where

def Show (A: Type) : Type =
  @self forall
  (0 P: forall (Show A) -> Type)
  (& newShow: forall
    (show: forall (a: A) -> #String)
    -> P (data \P n => n show)
  ) -> P self

def newShow (0 A: Type) (show: forall (a: A) -> #String): Show A
  = data \P n => n show

def show (0 A: Type) (impl: Show A) (x: A): #String
  = (case impl) (\_ => #String)
        (\show_a => show_a x)

def stringShow: Show #String
  = newShow #String (\s => #String.cons '\"' (#String.concat s "\""))

def base64 : List #Char =
    (List.cons #Char '0' (List.cons #Char '1' (List.cons #Char '2' (List.cons #Char '3' (List.cons #Char '4' (List.cons #Char '5'
    (List.cons #Char '6' (List.cons #Char '7' (List.cons #Char '8' (List.cons #Char '9' (List.cons #Char 'A' (List.cons #Char 'B'
    (List.cons #Char 'C' (List.cons #Char 'D' (List.cons #Char 'E' (List.cons #Char 'F' (List.cons #Char 'G' (List.cons #Char 'H'
    (List.cons #Char 'I' (List.cons #Char 'J' (List.cons #Char 'K' (List.cons #Char 'L' (List.cons #Char 'M' (List.cons #Char 'N'
    (List.cons #Char 'O' (List.cons #Char 'P' (List.cons #Char 'Q' (List.cons #Char 'R' (List.cons #Char 'S' (List.cons #Char 'T'
    (List.cons #Char 'U' (List.cons #Char 'V' (List.cons #Char 'W' (List.cons #Char 'X' (List.cons #Char 'Y' (List.cons #Char 'Z'
    (List.cons #Char 'a' (List.cons #Char 'b' (List.cons #Char 'c' (List.cons #Char 'd' (List.cons #Char 'e' (List.cons #Char 'f'
    (List.cons #Char 'g' (List.cons #Char 'h' (List.cons #Char 'i' (List.cons #Char 'j' (List.cons #Char 'k' (List.cons #Char 'l'
    (List.cons #Char 'm' (List.cons #Char 'n' (List.cons #Char 'o' (List.cons #Char 'p' (List.cons #Char 'q' (List.cons #Char 'r'
    (List.cons #Char 's' (List.cons #Char 't' (List.cons #Char 'u' (List.cons #Char 'v' (List.cons #Char 'w' (List.cons #Char 'x'
    (List.cons #Char 'y' (List.cons #Char 'z' (List.cons #Char '+' (List.cons #Char '/' (List.nil #Char))))
    )))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))


def showDigit (base n : Nat): #String
  =
  let m : Nat = mod n base;
  #String.cons
    (if #Char
        (and (gtn base (from_natural 0)) (lte base (from_natural 64)))
        (Maybe.default #Char (List.at #Char base64 m) '#')
        '#'
    )
    ""

def toBase (base : Nat) (n : Nat): List Nat
  = letrec fun : (forall Nat Nat (List Nat) -> List Nat) =
        (\base n list => (case (divMod n base)) (\_ => List Nat)
            (\div mod =>
                let l : List Nat = List.cons Nat mod list;
                (case div) (\_ => List Nat)
                    l
                    (\_ => fun base div l)
            )
        );
    fun base n (List.nil Nat)

def toStringOfBase (base : Nat) (n : Nat): #String
  = let digits : List Nat = toBase base n;
  List.foldr Nat #String (\digit str => #String.concat str (showDigit (from_natural 10) digit)) "" digits

def natShow: Show Nat
  = newShow Nat (toStringOfBase (from_natural 10))


def deriveMaybeShow (A : Type) (impl : Show A): Show (Maybe A)
  = newShow (Maybe A)
        (\m =>
            (case m) (\_ => #String)
                "none"
                (\a => #String.concat "just " (show A impl a))
        )

def deriveListShow (A : Type) (impl : Show A): Show (List A)
  = let subShow : forall A #String -> #String = (\a str =>
        #String.concat str (#String.concat ", " (show A impl a))
    );
  newShow (List A)
        (\list =>
            #String.concat "List ["
            (#String.concat ((case list) (\_ => #String)
                ""
                (\head tail => List.foldr A #String subShow (show A impl head) list)
                )
            "]")
        )

def derivePairShow (A B : Type) (implA : Show A) (implB : Show B): Show (Pair A B)
  = newShow (Pair A B)
        (\p =>
            (case p) (\_ => #String)
                (\a b => #String.concat "("
                    (#String.concat (show A implA a)
                    (#String.concat ", " (#String.concat (show B implB b) ")")))
                )
        )

def deriveMapShow (K V : Type) (ord : Ordered K) (implK : Show K) (implV : Show V): Show (Map K V ord) =
  letrec pairShow : ∀ (Pair K V) -> #String = (\p =>
    #String.concat (show K implK (Pair.fst K V p))
    (#String.concat " => " (show V implV (Pair.snd K V p)))
  );
  letrec subShow : ∀ (Pair K V) #String -> #String = (\p str =>
        #String.concat str (#String.concat ", " (pairShow p))
    );
  newShow (Map K V ord)
        (\m =>
            let list : List (Pair K V) = Map.toList K V ord m;
            #String.concat "Map {"
            (#String.concat ((case list) (\_ => #String)
                ""
                (\head tail => List.foldr (Pair K V) #String subShow (pairShow head) tail)
                )
            "}")
        )

def deriveVectorShow (0 A : Type) (size : Nat) (impl : Show A): Show (Vector A size) =
  letrec showIt : ∀ A -> #String = show A impl;
  let subShow : forall A #String -> #String = (\a str =>
        #String.concat str (#String.concat ", " (showIt a))
    );
  newShow (Vector A size)
        (\vec =>
            #String.concat "Vector ("
            (#String.concat (show Nat natShow size)
            (#String.concat ") ["
            (#String.concat ((case vec) (\_ _ => #String)
                    ""
                    (\size head tail => Vector.foldr A #String size subShow (showIt head) tail))
                "]")))
        )


{| Get a matrix show instance
|}
def deriveMatrixShow (0 A : Type) (impl : Show A) (rows cols : Nat): Show (Matrix A rows cols) =
  letrec showIt : ∀ A -> #String = show A impl;
  letrec subShow : forall A #String -> #String = (\a str =>
        #String.concat str (#String.concat " " (showIt a))
    );
  letrec showRow : ∀ (Vector A cols) #String -> #String = (\row str =>
    #String.concat
      str
      ((case row) (\_ _ => #String)
        "\n"
        (\cols head tail => Vector.foldr A #String cols subShow (showIt head) tail))
  ); 
  (newShow (Matrix A rows cols)
        (\matrix =>
            (case matrix) (\_ rows cols => #String)
              (\rowsVec =>

                #String.concat "Matrix ("
                (#String.concat (show Nat natShow rows)
                (#String.concat " x "
                (#String.concat (show Nat natShow cols)
                (#String.concat ")\n["
                (#String.concat (Vector.foldr (Vector A cols) #String rows showRow rowsVec)
                    "]"
                )))
              )))
        ))
