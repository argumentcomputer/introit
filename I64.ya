package I64
  import Bool (Bool)
  import Bool as Bool
  import Is (Is)
  import Is as Is
  import Pair (Pair)
  import Pair as Pair
  import Maybe (Maybe)
  import Maybe as Maybe
  import U32 (U32)
where

def I64: Type = #I64

def MAX: I64 = #I64.max
def MIN: I64 = #I64.min

def abs: ∀ (x: I64) -> #U64 = #I64.abs
def sgn: ∀ (x: I64) -> Bool = #I64.sgn

def eql: ∀ (x y: I64) -> Bool = #I64.eql
def lte: ∀ (x y: I64) -> Bool = #I64.lte
def lth: ∀ (x y: I64) -> Bool = #I64.lth
def gte: ∀ (x y: I64) -> Bool = #I64.gte
def gth: ∀ (x y: I64) -> Bool = #I64.gth
def and: ∀ (x y: I64) -> Bool = #I64.and
def xor: ∀ (x y: I64) -> Bool = #I64.xor
def or: ∀ (x y: I64) -> Bool = #I64.or
def neq (x y: I64): Bool = Bool.not (eql x y)

def add: ∀ (x y: I64) -> I64 = #I64.add

def SafeAdd (x y: I64): Bool =
  Bool.not
    (Bool.and
      (Bool.eql (sgn x) (sgn y))
      (Bool.neq (sgn x) (sgn (#I64.add x y)))
    )

def addSafe (x y: I64) (0 e: Is (SafeAdd x y)): I64 = #I64.add x y

def sub: ∀ (x y: I64) -> I64 = #I64.sub

def SafeSub (x y: I64): Bool =
  Bool.not
    (Bool.and
      (Bool.eql (sgn x) (Bool.not (sgn y)))
      (Bool.neq (sgn x) (sgn (#I64.sub x y)))
    )

def subSafe (x y: I64) (0 e: Is (lte y x)): I64 = #I64.sub x y

def mul: ∀ (x y: I64) -> I64 = #I64.mul

def SafeMul (x y: I64): Bool =
  Bool.or (eql x +0i64)
    ((case (eql y +0i64)) (λ _ => Bool)
       Bool.true
       (eql (#I64.div (#I64.mul x y) y) x)
    )

def mulSafe (x y: I64) (0 e: Is (SafeMul x y)): I64 = #I64.mul x y

def div (x y: I64): Maybe I64 =
  (case (neq y +0i64)) (λ _ => Maybe I64)
    (Maybe.some I64 (#I64.div x y))
    (Maybe.none I64)

def divSafe (x y: I64) (0 e: Is (neq y +0i64)): I64 = #I64.div x y

def mod (x y: I64): Maybe I64 =
  (case (neq y +0i64)) (λ _ => Maybe I64)
    (Maybe.some I64 (#I64.mod x y))
    (Maybe.none I64)

def modSafe (x y: I64) (0 e: Is (neq y +0i8)): I64 = #I64.mod x y

def pow: ∀ (x: I64) (y: U32) -> I64 = #I64.pow
def shl: ∀ (x: U32) (y: I64) -> I64 = #I64.shl
def shr: ∀ (x: U32) (y: I64) -> I64 = #I64.shr
def rol: ∀ (x: U32) (y: I64) -> I64 = #I64.rol
def ror: ∀ (x: U32) (y: I64) -> I64 = #I64.ror

def countZeros: ∀ (x: I64) -> U32 = #I64.count_zeros
def countOnes: ∀ (x: I64) -> U32 = #I64.count_ones

def SafeToU8 (x: I64): Bool = Bool.and (sgn x) (lte x (#U8.to_I64 #U8.max))

def toU8 (x: I64): Maybe #U8 =
  (case (SafeToU8 x)) (λ _ => Maybe #U8)
    (Maybe.some #U8 (#I64.to_U8 x))
    (Maybe.none #U8)

def toU8Safe (x: I64) (0 e: Is (SafeToU8 x)): #U8 = #I64.to_U8 x

def SafeToU16 (x: I64): Bool = Bool.and (sgn x) (lte x (#U16.to_I64 #U16.max))

def toU16 (x: I64): Maybe #U16 =
  (case (SafeToU16 x)) (λ _ => Maybe #U16)
    (Maybe.some #U16 (#I64.to_U16 x))
    (Maybe.none #U16)

def toU16Safe (x: I64) (0 e: Is (SafeToU16 x)): #U16 = #I64.to_U16 x


def toU32 (x: I64): Maybe #U32 =
  (case (sgn x)) (λ _ => Maybe #U32)
    (Maybe.some #U32 (#I64.to_U32 x))
    (Maybe.none #U32)

def toU32Safe (x: I64) (0 e: Is (sgn x)): #U32 = #I64.to_U32 x

def toU64 (x: I64): Maybe #U64 =
  (case (sgn x)) (λ _ => Maybe #U64)
    (Maybe.some #U64 (#I64.to_U64 x))
    (Maybe.none #U64)

def toU64Safe (x: I64) (0 e: Is (sgn x)): #U64 = #I64.to_U64 x

def toNat (x: I64): Maybe #Nat =
  (case (sgn x)) (λ _ => Maybe #Nat)
    (Maybe.some #Nat (#I64.to_Nat x))
    (Maybe.none #Nat)

def toNatSafe (x: I64) (0 e: Is (sgn x)): #Nat = #I64.to_Nat x

def SafeToI8 (x: I64): Bool =
  Bool.or (gte x (#I8.to_I64 #I8.min)) (lte x (#I8.to_I64 #I8.max))

def toI8 (x: I64): Maybe #I8 =
  (case (SafeToI8 x)) (λ _ => Maybe #I8)
    (Maybe.some #I8 (#I64.to_I8 x))
    (Maybe.none #I8)

def toI8Safe (x: I64) (0 e: Is (SafeToI8 x)): #I8 = #I64.to_I8 x

def SafeToI16 (x: I64): Bool =
  Bool.or (gte x (#I16.to_I64 #I16.min)) (lte x (#I16.to_I64 #I16.max))

def toI16 (x: I64): Maybe #I16 =
  (case (SafeToI16 x)) (λ _ => Maybe #I16)
    (Maybe.some #I16 (#I64.to_I16 x))
    (Maybe.none #I16)

def toI16Safe (x: I64) (0 e: Is (SafeToI16 x)): #I16 = #I64.to_I16 x

def SafeToI32 (x: I64): Bool =
  Bool.or (gte x (#I32.to_I64 #I32.min)) (lte x (#I32.to_I64 #I32.max))

def toI32 (x: I64): Maybe #I32 =
  (case (SafeToI32 x)) (λ _ => Maybe #I32)
    (Maybe.some #I32 (#I64.to_I32 x))
    (Maybe.none #I32)

def toI32Safe (x: I64) (0 e: Is (SafeToI32 x)): #I32 = #I64.to_I32 x

def toInt: ∀ (x: I64) -> #Int = #I64.to_Int
